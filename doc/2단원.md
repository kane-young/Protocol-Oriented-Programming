# 타입 선택

대다수의 전통적인 객체지향 프로그래밍 언어와 달리 Swift의 Class와 Struct는 비슷한 점이 매우 많다. **애플은 참조타입보다 구조체와 같은 값 타입을 선호할 것을 권고**하지만 어떠한 장점이 있는지는 현재 잘 모른다. 실제로 어떠한 장점이 있을지 알아보자!

- **클래스란 무엇이며 어떻게 사용하는가?**
- **구조체란 무엇이며 어떻게 사용하는가?**
- **열거형이란 무엇이며 어떻게 사용하는가?**
- **튜플이란 무엇이며 어떻게 사용하는가?**
- **값 타입과 참조 타입의 차이점은 무엇인가?**



스위프트에서는 타입을

- **이름 있는 타입(클래스, 구조체, 열거형, 프로토콜)**
- **이름 없는 타입(array, set, dictionary)**



**그리고, 스위프트에서는 일반적으로 다른 언어에서 원시 타입이라 불리는 데이터 타입의 대부분이 이름 있는 타입이며, 스위프트 표준 라이브러리는 구조체를 사용해 이러한 데이터 타입을 구현했다**



### 클래스

다른 객체지향 프로그래밍언어에서는 `클래스`로 청사진을 나타냈다. 클래스는 객체의 프로퍼티와 메소드, 그리고 생성자를 단일 타입으로 캡슐화하는 일종의 구성체다



### 구조체

애플은 스위프트 개발자에게 참조 타입보다 값 타입을 선호하라고 이야기한다. 실제로 스위프트 표준 라이브러리를 살펴보면 구조체를 사용해서 타입 대부분을 구현했다는 것을 알 수 있다.



클래스와 구조체의 차이점

- 이 구조체에서는 생성자를 정의하지 않았는데, 구조체는 작성자가 생성자를 제공하지 않을 경우 초기화돼야 하는 모든 프로퍼티를 설정하기 위한 기본 생성자를 만들어주기 때문이다
- 구조체의 메소드 중 일부는 mutating 키워드를 사용한다. 구조체는 값 타입이기 때문에 기본적으로 인스턴스 메소드 내부에서는 구조체 프로퍼티 값을 변경할 수 없다



### 접근 제어

**접근제어(Access Level Control)**는 외부 코드에 대한 접근성과 가시성을 제한한다. 접근제어는 상세 구현을 숨기고 외부 코드가 접근했으면 하는 인터페이스만 노출시킨다.

- **Open** : 가장 눈에 띄는 접근 제어 단계이다. open온 모듈을 임포트하고자 하는 어느 곳에서든 프로퍼티나 메소드, 클래스 등을 사용할 수 있게 해준다. **open으로 표시된 아이템은 해당 아이템이 정의된 모듈 내에 있는 모든 아이템에서 서브클래싱이나 오버라이딩을 할 수 있으며, 해당 아이템이 정의된 모듈을 임포트한 모듈에서도 서브클래싱하거나 오버라이딩할 수 있다.** 주로 프레임워크에서 프레임워크의 공개 API를 노출시키기 위해 사용한다
- **Public**: 모듈을 임포트하고나 하는 어느 곳에서나 프로퍼티나 메소드, 클래스 등을 사용할 수 있게 해준다. 기본적으로 접근 제어 단계를 Public으로 하는 아이템은 누구나 사용할 수 있다. **public으로 표기된 아이템은 해당 아이템이 정의된 모듈 내에 있는 모든 아이템에서 서브클래싱하거나 오버라이딩할 수 있다.** public은 주로 프레임워크에서 프레임워크의 공개 API를 노출시키기 위해 있다.
- **Internal**: 기본 접근 단계로, 아이템이 정의된 모듈 내부에서 프로퍼티와 메소드 클래스 등을 사용할 수 있게 해준다. 

- **Fileprivate**: 아이템이 **정의되어 있는 소스 파일과 동일한 코드 내부에**서 프로퍼티와 메소드의 접근을 허용한다
- **Private**: 해당 아이템이 **정의되어 있는 코드 내부에서**만 프로퍼티와 메소드, 클래스 등을 사용하는 것을 허용하도록 한다



인자 중 어느 한 가지나 반환 타입의 접근 단계가 private인 경우에는 외부 코드가 private 타입에 접근할 수 없기 때문에 해당 메소드를 public으로 설정할 수 없다

클래스나 구조체의 접근 단계를 private으로 설정한 경우에는 메소드나 프로퍼티의 접근 단계를 public으로 설정할 수 없는데, 이는 클래스가 private인 경우에는 외부 코드에서 생성자에 접근할 수 없기 때문이다



### 열거형

대부분 언어에서는 열거형은 요소라 불리는 이름이 있는 값으로 구성된 데이터 타입에 지나지 않는다. 하지만 스위프트에서 열거형은 더 많은 능력이 있다. 기능면에서는 클래스나 구조체와 매우 가까우면서도 여전히 다른 언어에서 사용하는 것처럼 사용한다.



```swift
enum Devices: String {
	case IPod = "iPod" //raw Values 사용
	case IPhone = "iPhone"
	case IPad = "iPad"
}

//연관 값 저장 가능
enum Devices {
  case IPod(model: Int, year: Int, memory: Int)
  case IPhone(model: String, memory: Int)
  case IPad(model: String, memory: Int)
}
var myPhone = Devices.IPhone(model: "6", memory: 64)
```

**그리고 또한 열거형은 클래스나 구조체처럼 연산 프로퍼티나 생성자 또는 메소드를 가질 수도 있다**

```swift
enum Reindeer: String {
	case Dasher, Dancer, Comet
	static var allCases: [Reindeer] {
		return [Dasher, Dancer, Comet]
	}
	
	static func randomCase() -> Reindeer {
		let randomValue = Int(arc4random_uniform(UInt32(allCases.count)))
		return allCases[randomValue]
	}
}
```



### 프로토콜

실제로 인스턴스를 생성할 수 없기 때문에 일부 사람은 프로토콜을 타입으로 간주한다는 점에 놀라워하지만, 프로토콜은 타입으로 사용할 수 있다.

그럼 참조 타입?? 값 타입??

NoNob... 인스턴스를 생성할 수 없기에 값 타입도 참조 타입도 아니다



### 값 타입과 참조 타입

값 타입과 참조 타입 사이에는 몇 가지 근본적인 차이점이 있다. 주된 차이점은 값 타입이나 참조 타입의 인스턴스가 전달되는 방식에 있다. 



값 타입의 인스턴스를 전달하는 경우 원본의 복사본을 전달하게 된다. 이는 한 인스턴스가 변경되더라도 다른 인스턴스에는 영향을 끼치지 않는다는 것이다. 왜냐?? 복사본이니깐!!

But, 참조 타입의 인스턴스를 전달하는 경우 원본 인스턴스의 참조를 전달하게 된다. 이는 두 참조 모두 같은 인스턴스를 가리키게 있다는 의미며, 그러므로 어느 한 참조가 변경되면 다른 참조에 영향을 미치게 된다.



값 타입 인스턴스는 이를 생성한 함수나 타입에 한정되므로 값 타입을 사용하면 예상치 못한 변화로부터 인스턴스를 보호할 수 있다. **또한 값 타입은 같은 여러 개의 참조가 같은 인스턴스를 참조하지 않게 보호해준다.**



함수에서 값 타입을 참조할 수 있게 해주는 방법이 있는데 inout 매개변수가 바로 그 방법이다

```swift
func getGreadForAssignment(assignment: inout MyValueType) {
	//...
}
```



### 참조 타입만을 위한 재귀적 데이터 타입

**재귀적 데이터 타입은 같은 타입의 다른 값을 프로퍼티로 갖는 타입을 말한다.** **리스트나 트리 같은 동적 자료 구조를 정의할 때** 재귀적 데이터 타입을 사용한다. 이러한 동적 자료 구조는 런타임에서 요구사항에 따라 크기가 늘어나거나 줄어들 수 있다



![스크린샷 2021-05-23 오후 2.52.22](/Users/leeyoungwoo/Desktop/스크린샷 2021-05-23 오후 2.52.22.png)

```swift
class LinkedListReferenceType {
	var value: String
	var next: LinkedListReferenceType?
	init(value: String) {
		self.value = value
	}
}
```





### 참조 타입만을 위한 상속

**상속**은 다른 클래스로부터 비롯된 클래스와 관련이 있다. 

서브클래스는 슈퍼클래스로부터 메소드, 프로퍼티, 그 외에 다른 특징들을 상속받는다. 상속을 사용하면 다수의 상속 레이어를 갖는 클래스 계층을 생성할 수 있다

 But, 클래스 계층에서 가장 큰 문제점은 바로 **복잡성**에 있다. 복잡한 클래스 계층을 가진 경우 클래스를 변경하고 나면 모든 서브클래스에 어떻게 영향을 미칠지 인식하지 못하기 쉽다. 

따라서 계층에 있는 클래스를 변경하기 전에 이러한 변경 사항이 계층 내부의 모든 클래스에 어떻게 영향을 미칠지 이해해야만 한다.



**그래서 특별한 이유가 없는 한 복잡한 클래스 계층 구조는 피하고 프로토콜지향적인 접근법을 사용하는 것이 좋다!!**



### 다니내믹 디스패치

앞서 설명한 참조 타입만을 위한 상속 절에서 슈퍼클래스에 정의된 기능을 상속하고 오버라이드하기 위해 클래스에서 상속을 어떻게 사용할 수 있는지에 살펴봤다. 어떻게 적절한 구현체를 선택해야 하는지 매우 궁금한데...

 **호출할 구현체를 선택하는 과정은 런타임 단계에서 수행되며, 이는 다이내믹 디스패치로 알려져 있다**



바로 윗 문장의 뜻은... `구현체가 런타임 단계에서 선택된다는 점`이다

대부분 애플리케이션의 경우 이러한 오버헤드는 문제가 아니지만, 게임과 같이 성능에 민감한 애플리케이션의 경우에는 이러한 오버헤드가 주요한 문제가 될 수 있다.



**다이내믹 디스패치와 관련해서 오버헤드를 줄일 수 있는 방법 중 하나로 final 키워드를 사용하는 방법이 있다. final 키워드는 클래스나 메소드 또는 함수에 제약을 설정하는데, 메소드나 함수의 경우에는 오버라이드할 수 없다는 것을 나타내고, 클래스의 경우에는 서브클래싱을 할 수 없다는 것을 나타낸다.**



```swift
class Animal {
	final var numberOfLegs = 0
	func sleeps() {
		print("zzzzz")
	}
	
	final func walking() {
		print("walking on \(numberOfLegs)")
	}
	
	func speaking() {
		print("No sound")
	}
}
```

**이런식으로 final키워드를 지정해주면 walking() 함수는 간접 호출이 아닌 직접 호출을 할 수 있게 해주며, 이는 애플리케이션에 약간의 성능 향상을 가져온다. 클래스 상속을 반드시 사용해야만 하는 경우라면 가능한 final 키워드를 사용하는 것이 좋다. 그러나 이러한 오버헤드를 피하기 위해서는 값 타입을 갖는 프로토콜 설계를 사용하는 편이 더 낫다.**



### 스위프트 내장 타입

스위프트는 몇 가지 표준 자료 구조도 정의해 놓고 있으며, 배열과 딕셔너리, 그리고 셋(Set) 등이 여기에 해당된다. 데이터 타입과 마찬가지로 이러한 자료 구조 역시 스위프트 표준 라이브러리에 구조체로 구현되어 있다. 값 타입을 다른 변수에 할당될 때 자료 구조의 복사본을 전달하기 때문에 자료 구조가 많은 양의 요소를 포함하는 경우 이러한 자료 구조의 성능이 어떨지 궁금할 것이다.

이러한 것을 COW(Copy On Write)라고 한다



### COW(Copy On Write)

**구조체와 같은 값 타입의 인스턴스가 다른 변수에 할당**되면 두 번째 변수는 **해당 인스턴스의 복사본을 전달**받게 된다. 이는 50,000개의 요소를 가진 배열이 있는 경우 해당 배열을 **두 번째 변수에 할당하거나 배열을 코드의 다른 부분에 전달하는 경우 런타임에서 요소 50,000개 모두를 복사해야만 한다는 것**을 의미한다. 이러한 동작은 성능에 심각한 영향을 끼칠 수 있으나, **배열과 같은 스위프트 내장 구조에서는 Copy-On-Write 덕택에 이러한 영향이 감소한다.**



**스위프트에서는 Copy-On-Write를 이용해 자료 구조가 변경되지 않는 한 자료 구조의 두 번째 복사본을 만들지 않는다. 그렇기 때문에 50,000개의 요소를 가진 배열을 코드의 다른 부분에 전달하고, 코드에서 실제로 배열에 어떠한 변화도 주지 않는다면 모든 요소를 복사하는 런타임 오버헤드를 피할 수 있을 것이다**



하지만, 이러한 COW는 스위프트 표준 라이브러리에서 특정 타입에만 구현되어 있으며, 모든 값 타입이 무료로 사용할 수 있는 것은 아니다. But, But, 커스텀 데이터 타입에 COW를 적용할 수 있는 방법이 있다고 하니 그것은 4단원에서 확인!!

